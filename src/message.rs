//! Serialize and deserialize `Message`s.
use crate::header::Header;
use crate::resource_record::ResourceRecord;
use crate::sections::Question;
use crate::DecodeError;

/// `Message` models a DNS message as documented in [`4. Messages`] of RFC 1035.
/// Any message, whether it's a query or a reply, follows the same format.
/// They start with a `Header`. Followed by zero or more `Questions`.
/// What follows is a set of `ResourceRecords` answering the query, pointing to towards
/// an authority and hold additional information.
///
/// ```
/// use dns::Message;
/// // A series of bytes representing a query for orangetux.nl generated by calling
/// // `dig orangetux.nl +noedns`.
/// let buf = vec![244, 238, 1, 32, 0, 1, 0, 0, 0, 0, 0, 0, 9, 111, 114, 97, 110, 103, 101, 116, 117, 120, 2, 110, 108, 0, 0, 1, 0, 1];
///
/// let message: Message = Message::try_from(&mut buf.iter()).unwrap();
/// assert_eq!("orangetux.nl".to_string(), message.questions[0].qname);
/// assert_eq!(buf, message.into_bytes());
///
/// ```
/// [`4. Message`]: https://www.rfc-editor.org/rfc/rfc1035#section-4
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct Message {
    pub header: Header,

    /// A list of questions.
    pub questions: Vec<Question>,

    /// A list of answers to the query. The list might be empty.
    pub answers: Vec<ResourceRecord>,

    /// A list of records pointing to servers holding authority over the question. The list might
    /// be empty.
    pub authority: Vec<ResourceRecord>,

    /// A list with records holding additional information. The list might be empty.
    pub additional: Vec<ResourceRecord>,
}

impl TryFrom<&mut std::slice::Iter<'_, u8>> for Message {
    type Error = DecodeError;

    fn try_from(value: &mut std::slice::Iter<u8>) -> Result<Self, Self::Error> {
        let header = Header::try_from(&mut *value)?;
        let mut questions = Vec::with_capacity(header.qd_count.into());
        let mut answers = Vec::with_capacity(header.an_count.into());
        let mut authority = Vec::with_capacity(header.ns_count.into());
        let mut additional = Vec::with_capacity(header.ar_count.into());

        for _ in 0..header.qd_count {
            questions.push(Question::try_from(&mut *value)?);
        }
        for _ in 0..header.an_count {
            answers.push(ResourceRecord::try_from(&mut *value)?);
        }
        for _ in 0..header.ns_count {
            authority.push(ResourceRecord::try_from(&mut *value)?);
        }
        for _ in 0..header.ar_count {
            additional.push(ResourceRecord::try_from(&mut *value)?);
        }

        Ok(Message {
            header,
            questions,
            answers,
            authority,
            additional,
        })
    }
}

impl Message {
    /// Serialize the instance into bytes.
    pub fn into_bytes(self) -> Vec<u8> {
        let mut output = self.header.into_bytes();
        output.append(
            &mut self
                .questions
                .into_iter()
                .flat_map(|e| e.into_bytes())
                .collect(),
        );

        output.append(
            &mut self
                .answers
                .into_iter()
                .flat_map(|e| e.into_bytes())
                .collect(),
        );
        output.append(
            &mut self
                .authority
                .into_iter()
                .flat_map(|e| e.into_bytes())
                .collect(),
        );
        output.append(
            &mut self
                .additional
                .into_iter()
                .flat_map(|e| e.into_bytes())
                .collect(),
        );

        output
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::header::{OpCode, ResponseCode, Type};
    use crate::sections::{QClass, QType};

    #[test]
    fn test_serialization_and_deserialization() {
        let message = Message {
            header: Header {
                id: 1337,
                qr: Type::Query,
                op_code: OpCode::Query,
                authoritive_answer: false,
                truncated: false,
                recursion_desired: false,
                recursion_available: false,
                z: 0,
                r_code: ResponseCode::NoError,
                qd_count: 1,
                an_count: 0,
                ns_count: 0,
                ar_count: 0,
            },
            questions: vec![crate::sections::Question {
                qname: "orangetux.nl".to_string(),
                qtype: QType::A,
                qclass: QClass::IN,
            }],
            answers: vec![],
            authority: vec![],
            additional: vec![],
        };

        // Serialize the message to bytes...
        let bytes = message.clone().into_bytes();

        // ...than deseralize the bytes back to a `Message`.
        let copy_of_message = Message::try_from(&mut bytes.iter()).unwrap();

        assert_eq!(message, copy_of_message);
    }
}
